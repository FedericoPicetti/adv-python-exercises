from itertools import zip_longest
from functools import reduce

class TooHighOrderDivisorException(Exception): pass

def superscript(s):
    input = '0123456789'
    output = u'\u2070\u00b9\u00b2\u00b3\u2074\u2075\u2076\u2077\u2078\u2079'
    #input = '2'
    #output = '\N{SUPERSCRIPT TWO}'
    #print('\N{SUPERSCRIPT TWO}')
    return s.translate(str.maketrans(input, output))

class Polynomial:
    def __init__(self, *c):
        self.c = c

    def __repr__(self):
        s = ''
        for i in range(len(self.c)):
            exp = len(self.c) - 1 - i
            a = self.c[i]
            if a != 0:
                if a > 0:
                    s += '+'
                if a == -1 and exp != 0:
                    s += '-'
                elif a == 1 and exp != 0:
                    pass
                else:
                    s += str(a)
                if exp > 0:
                    s += 'x'
                if exp > 1:
                    s += (superscript(str(exp)))
        return s

    def __add__(a, b):
        return Polynomial(*list(reversed([x + y for x,y in zip_longest(reversed(a.c), reversed(b.c), fillvalue=0)])))

    def __sub__(a, b):
        b = Polynomial(*list(map(lambda x: -x, b.c)))
        return a + b

    def monomials(self):
        res = []
        for i in range(len(self.c)):
            if self.c[i] != 0:
                res.append(Polynomial(*([self.c[i]] + [0]*(len(self.c) -1-i))))
        return res
        
    def __lshift__(self, mon):
        b = mon.c[0]
        m = len(mon.c) - 1
        return Polynomial(*(list(map(lambda x: x*b, self.c)) + [0] * m))
        
    def __mul__(a, b):
        return reduce(lambda x,y: x+y, list(map(lambda x: b<<x, a.monomials())))
        
    def ruffini(self, other):
        if len(other.c) > 2:
            raise TooHighOrderDivisorException("ERROR!!! The divisor {} is too high order! It should be one!".format(other))
        r = -other.c[-1]//other.c[0]
        q = [self.c[0]]
        for a in self.c[1:]:
            q += [q[-1] * r+a]
        quotient = Polynomial(*q[:-1])
        remainder = q[-1] *other.c[0]
        return (quotient, remainder)
        
    def __truediv__(self, other):
        return self.ruffini(other)[0]
    
    def __mod__(self, other):
        return self.ruffini(other)[1]
                
if __name__ == "__main__":

    
    p = Polynomial(7, 0, 2, 0, -1)
    q = Polynomial(-1,0,42)
    r = Polynomial(3.2, 15, 0, 1, 4, 2, 0)
    
    
    print("p :- {}\nq :- {}\nr :- {}".format(p,q,r))

    z = p + q + r
    print("z :- {}".format(z))

    print("Monomials of z:", z.monomials() )

    print("z-r :- {}".format(z-r))

    print('The polynomials generated by q×p are:')
    for p1 in p.monomials():
        print("  · {}".format(q<<p1))

    print('p·q :- {} \nq·p :- {}'.format(p*q, q*p))

    r = Polynomial(2,-5,-1,6).ruffini(Polynomial(1,1))
    print('2x³-5x²-x+6/x+1 :- {} with remainder :- {} '.format(r[0],r[1]))

    p1 = Polynomial(2,3,0,-4)
    p2 = Polynomial(1,1)
    print('2x³+3x²-4/x+1 :- {} with remainder :- {} '.format((p1/p2),p1%p2))

    print("Let's try some impossible operations")
    try:
        print("  · Can I do {}/{}? ".format(q,p), end='')
        q/p
    except TooHighOrderDivisorException as e:
        print(e)
    try:
        print("  · Can I do {}%{}? ".format(q,p), end='')
        q%p
    except TooHighOrderDivisorException as e:
        print(e)
    try:
        print("  · Can I do {}.ruffini({})? ".format(q,p), end='')
        q.ruffini(p)
    except TooHighOrderDivisorException as e:
        print(e)


